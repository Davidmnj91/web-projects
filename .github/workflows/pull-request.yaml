name: Pull Request

on:
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

permissions:
  contents: write

jobs:
  changeset:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js and pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Check for changeset
        id: check_changeset
        run: |
          labels="${{ toJson(github.event.pull_request.labels) }}"
          title="${{ github.event.pull_request.title }}"

          # bypass if label exists
          if echo "$labels" | grep -q '"name": *"no-changeset-needed"'; then
            echo "status=bypass" >> $GITHUB_OUTPUT
            exit 0
          fi

          # bypass if PR title starts with chore: or docs:
          if echo "$title" | grep -Eiq '^(chore|docs)'; then
            echo "status=bypass" >> $GITHUB_OUTPUT
            exit 0
          fi

          # check for changeset
          if git diff --name-only origin/${{ github.base_ref }} | grep -q '^.changeset/.*\.md$'; then
            echo "status=found" >> $GITHUB_OUTPUT
          else
            echo "status=missing" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Manage PR comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = "${{ steps.check_changeset.outputs.status }}";
            const issue_number = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
            });

            const botComments = comments.filter(c =>
              c.user.type === "Bot" &&
              c.body.includes("This PR is missing a **Changeset**")
            );

            if (status === "missing") {
              if (botComments.length === 0) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number,
                  body: "âš ï¸ This PR is missing a **Changeset**.\n\n" +
                        "Please run `pnpm changeset` and commit the generated file under `.changeset/`.\n\n" +
                        "âž¡ï¸ Maintainers can bypass this check by adding the `no-changeset-needed` label.\n" +
                        "â„¹ï¸ PRs titled with `chore:` or `docs:` also skip this check automatically."
                });
              }
            } else {
              for (const comment of botComments) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: comment.id,
                });
              }
            }
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check PR Title
        id: check_title
        env:
          TITLE: ${{ github.event.pull_request.title }}
        run: |
          if [[ "$TITLE" =~ ^(fix|feat)(\(.*\))?:.+ ]]; then
            echo "âœ… PR title matches semantic release, starting deploy."
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ PR title '$TITLE' does not match 'fix' o 'feat'. Skipping deploy."
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect Affected Apps (Turbo)
        if: steps.check_title.outputs.should_deploy == 'true'
        id: affected
        run: |
          RAW_OUTPUT=$(npx turbo ls --filter="...[origin/main]" --filter="./apps/*" --output=json)
          CHANGED_APPS=$(echo "$RAW_OUTPUT" | jq -r '.packages[].path')

          if [ -z "$CHANGED_APPS" ] || [ "$CHANGED_APPS" == "null" ]; then
            echo "No apps affected."
            echo "AFFECTED_PATHS=" >> $GITHUB_ENV
          else
            APPS_ARRAY=()
            while IFS= read -r line; do
              APPS_ARRAY+=("$line")
            done <<< "$CHANGED_APPS"

            echo "AFFECTED_PATHS=${APPS_ARRAY[*]}" >> $GITHUB_ENV
            echo "âœ… Affected apps detected: ${APPS_ARRAY[*]}"
          fi
      - name: Deploy to Vercel
        if: steps.check_title.outputs.should_deploy == 'true' && env.AFFECTED_PATHS != ''
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        run: |
          npm i -g vercel

          read -ra APPS <<< "$AFFECTED_PATHS"

          for app in "${APPS[@]}"; do
            echo "------------------------------------------------"
            echo "ðŸš€ Processing: $app"

            cd "$app"

            if [ ! -f "vercel.json" ]; then
              echo "âš ï¸ Cannot find vercel.json in $app. Skipping..."
              cd - > /dev/null
              continue
            fi

            PROJECT_ID=$(jq -r '.relatedProjects[0]' vercel.json)
            if [ "$PROJECT_ID" == "null" ] || [ -z "$PROJECT_ID" ]; then
               echo "âŒ Error: No se pudo leer el projectId de vercel.json"
               exit 1
            fi
            echo "ðŸ”— Linked to Project ID: $PROJECT_ID"

            VERCEL_PROJECT_ID=$PROJECT_ID vercel pull --yes --environment=preview --token=$VERCEL_TOKEN
            VERCEL_PROJECT_ID=$PROJECT_ID vercel build --token=$VERCEL_TOKEN
            DEPLOY_URL=$(VERCEL_PROJECT_ID=$PROJECT_ID vercel deploy --prebuilt --token=$VERCEL_TOKEN)
            echo "âœ… Deployed at: $DEPLOY_URL"

            cd - > /dev/null
          done
