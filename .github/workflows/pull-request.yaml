name: Pull Request

on:
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  check-changesets:
    runs-on: ubuntu-latest
    name: ðŸ›¡ï¸ Check Changesets
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changeset
        id: check_changeset
        run: |
          labels="${{ toJson(github.event.pull_request.labels) }}"
          title="${{ github.event.pull_request.title }}"

          # 1. Bypass si existe la etiqueta
          if echo "$labels" | grep -q '"name": *"no-changeset-needed"'; then
          echo "status=bypass" >> $GITHUB_OUTPUT
          echo "â© Bypass: Label found."
          exit 0
          fi

          # 2. Bypass si el tÃ­tulo es chore o docs
          if echo "$title" | grep -Eiq '^(chore|docs)'; then
          echo "status=bypass" >> $GITHUB_OUTPUT
          echo "â© Bypass: Title is chore/docs."
          exit 0
          fi

          # 3. Buscar archivo .changeset
          # Nota: Ajustado para asegurar que comparamos correctamente las ramas
          git fetch origin ${{ github.base_ref }}
          if git diff --name-only origin/${{ github.base_ref }} | grep -q '^.changeset/.*\.md$'; then
          echo "âœ… Changeset found."
          echo "status=found" >> $GITHUB_OUTPUT
          else
          echo "âŒ Changeset missing."
          echo "status=missing" >> $GITHUB_OUTPUT
          # No hacemos exit 1 aquÃ­ todavÃ­a para permitir que el paso del comentario se ejecute
          fi

          - name: Manage PR comment
            if: always() # Se ejecuta siempre, incluso si fallÃ³ el paso anterior (aunque aquÃ­ controlamos el fallo manualmente)
            uses: actions/github-script@v7
            with:
              script: |
                const status = "${{ steps.check_changeset.outputs.status }}";
                const issue_number = context.issue.number;

                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number,
                });

                const botComments = comments.filter(c =>
                  c.user.type === "Bot" &&
                  c.body.includes("This PR is missing a **Changeset**")
                );

                if (status === "missing") {
                  if (botComments.length === 0) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number,
                      body: "âš ï¸ This PR is missing a **Changeset**.\n\n" +
                            "Please run `pnpm changeset` and commit the generated file under `.changeset/`.\n\n" +
                            "âž¡ï¸ Maintainers can bypass this check by adding the `no-changeset-needed` label.\n" +
                            "â„¹ï¸ PRs titled with `chore:` or `docs:` also skip this check automatically."
                    });
                  }
                  // Hacemos fallar el job AHORA, despuÃ©s de comentar
                  core.setFailed("Changeset missing");
                } else {
                  // Si ya existe o bypass, borramos el comentario del bot si existe
                  for (const comment of botComments) {
                    await github.rest.issues.deleteComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: comment.id,
                    });
                  }
                }
              github-token: ${{ secrets.GITHUB_TOKEN }}


  deploy-preview:
    runs-on: ubuntu-latest
    name: ðŸš€ Deploy Preview
    if: github.event.action != 'labeled'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check PR Title (Deploy Logic)
        id: check_title
        env:
          TITLE: ${{ github.event.pull_request.title }}
        run: |
          if [[ "$TITLE" =~ ^(fix|feat)(\(.*\))?:.+ ]]; then
            echo "âœ… TÃ­tulo vÃ¡lido para deploy."
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "Running validation only (no deploy for chore/docs/etc)."
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node & Pnpm
        if: steps.check_title.outputs.should_deploy == 'true'
        uses: pnpm/action-setup@v4
        with:
          run_install: false

      - uses: actions/setup-node@v4
        if: steps.check_title.outputs.should_deploy == 'true'
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Detect Affected Apps (Turbo)
        if: steps.check_title.outputs.should_deploy == 'true'
        id: affected
        run: |
          RAW_OUTPUT=$(npx turbo ls --filter="...[origin/main]" --filter="./apps/*" --output=json)
          CHANGED_APPS=$(echo "$RAW_OUTPUT" | jq -r '.packages.items[].path')

          if [ -z "$CHANGED_APPS" ] || [ "$CHANGED_APPS" == "null" ]; then
            echo "No apps affected."
            echo "AFFECTED_PATHS=" >> $GITHUB_ENV
          else
            APPS_ARRAY=()
            while IFS= read -r line; do
              APPS_ARRAY+=("$line")
            done <<< "$CHANGED_APPS"

            echo "AFFECTED_PATHS=${APPS_ARRAY[*]}" >> $GITHUB_ENV
            echo "âœ… Affected apps detected: ${APPS_ARRAY[*]}"
          fi

      - name: Deploy to Vercel
        if: steps.check_title.outputs.should_deploy == 'true' && env.AFFECTED_PATHS != ''
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        run: |
          npm i -g vercel

          read -ra APPS <<< "$AFFECTED_PATHS"

          for app in "${APPS[@]}"; do
            echo "------------------------------------------------"
            echo "ðŸš€ Processing: $app"

            if [ ! -f "$app/vercel.json" ]; then
              echo "âš ï¸ Cannot find vercel.json in $app. Skipping..."
              cd - > /dev/null
              continue
            fi

            PROJECT_ID=$(jq -r '.relatedProjects[0]' "$app/vercel.json")
            if [ "$PROJECT_ID" == "null" ] || [ -z "$PROJECT_ID" ]; then
               echo "âŒ Error: Cannot read projectId from $app/vercel.json"
               exit 1
            fi
            echo "ðŸ”— Linked to Project ID: $PROJECT_ID"

            VERCEL_PROJECT_ID=$PROJECT_ID vercel pull --yes --environment=preview --token=$VERCEL_TOKEN
            VERCEL_PROJECT_ID=$PROJECT_ID vercel build --token=$VERCEL_TOKEN
            DEPLOY_URL=$(VERCEL_PROJECT_ID=$PROJECT_ID vercel deploy --token=$VERCEL_TOKEN)

            echo "âœ… Deployed at: $DEPLOY_URL"

            cd - > /dev/null
          done
